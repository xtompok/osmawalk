\chapter{Rešerše}

\section{Time dependent modely}
\section{Time expanded modely}
\section{Contraction hierarchy}
\section{RAPTOR}
RAPTOR (Round-Based Public Transport Routing) \citep*{RAPTOR} je oproti
time-dependent modelům založen na zcela odlišných myšlenkách a při svém běhu
nevyužívá Dijkstrův algoritmus. RAPTOR se snaží využít co nejvíce vlastností,
kterými se odlišuje síť veřejné dopravy od obyčejné cestní sítě. Také umožňuje
snadno optimalizovat na počet přestupů.

Algoritmus pracuje po kolech. Každé kolo zanmená nástup do dalšího dopravního
prostředku, celkově je tedy počet kol o 1 větší než maximální počet přestupů.
Algoritmus pracuje s linkami. Každá linka má několik spojů, což jsou konkrétní
vozidla, která všechna projíždí stejnou posloupnost zastávek. Každý spoj má
uloženy časy odjezdu z jednotlivých zastávek, předpokládáme, že se dva spoje
jedné linky na trase nepředjíždí. Pro každou zastávku si pro každé kolo
pamatujeme, zda a kdy je dosažitelná pomocí kterého kola. Nedosažitelnost
zastávky reprezentujeme pomocí nastavení času příjezdu v daném kole na $\infty$.

Na začátku jsou všechny zastávky ve všech kolech nedosažitelné. Nastavíme
výchozí zastávce čas dosažení v prvním kole na zadaný čas odjezdu a spustíme
algoritmus. Ten postupně prochzí linky po jejich zastávkách a pokud narazí na
dosažitelnou zastávku, tak najde nejbližší spoj linky, který z dané zastávky
odjíždí po čase dosažitelnosti a tímto spojem se \uv{vydá} a průběžně upravuje
časy dosažitelnosti na dalších zastávkách. Pokud po cestě nalezne další
dosažitelnou zastávku, jako spoj z této zastávky vybere ten z původního spoje a
spoje navazujícího na původní čas dosažitelnosti, který odjíždí dříve a takto
pokračuje až do konce linky. Po průchodu všech linek se všechny časy
dosažitelnosti zkopírují do dalšího kola a algoritmus se znovu spustí. Po
stanoveném počtu kol algoritmus skončí a u jednotlivých zastávek je pro každé
kolo (odpovídající počtu přestupů - 1) uloženo, zda je s daným počtem přestupů
dosažitelná a v jakém čase. K jednotlivým časům u zastávek je vhodné si uložit
ilinku, která způsobila úpravu na daný čas, abychom byli schopni zrekonstruovat
spojení využité k dosažení dané zastávky. 

Tento algoritus je snadno implementovatelný a při vhodně zvolených datových
strukturách velmi rychlý a vhodně využívající keš. 

\subsection{Uložení dat}
Pro rychlý výpočet a efektivní využití cache je potřeba mít vhodně uložená data.
Data stejného typu jsou vždy uložená v poli za sebou. Pokud různé objekty mají
každý mít seznam stejného typu, jsou všechna data od všech objektů držena v
jednom poli a každý objekt si drží počet svých prvků a odkaz na první z nich.
Tímto má každý objekt vyhrazen svůj úsek a může s ním efektivně pracovat. Tento
mechanismus nazveme \uv{polním mechanismem} a budeme na něj takto odkazovat ve
zbytku kapitoly.

Základem pro prohledávání je pole linek. Každá linka má odkaz na své zastávky a
na časy zastavení spojů v zastávkách. Obojí je implementováno polním mechanismem
a rozdělení na zastávky a spoje zajišťuje snadnou možnost hledání spojů v daný
čas. Časy zastavení spojů v zastávkách jsou uspořádány v poli za sebou podle
zastávek a pak podle času výjezdu spoje z výchozí zastávky. Protože
předpokládáme, že se spoje nepředjíždí a všechny spoje jedné linky mají stejný
počet zastávek, na předchozí spoj snadno přejdeme skokem v poli zastavení o
počet zastávek linky vzad, následující spoj najdeme obdobným skokem vpřed. Také
je možné pro konkrétní zastávku a konkrétní čas použít jednoduše binární
vyhledávání pro nalezení nejbližšího spoje odjíždějícího po konkrétním čase. 

Pro vyhledávání z konkrétní zastávky máme obdobně implementovány datové
struktury kolem zastávek. Zastávky jsou uloženy v poli za sebou, každá si drží
seznam linek, které jí projíždějí, a seznam pěších přestupů z dané zastávky. 
Obojí je reprezentováno polním mechanismem.   


\chapter{Rešerše}
Data o různých cestních sítích obvykle ukládáme ve formě grafu, ve kterém pak
vyhledáváme jednotlivé trasy pomocí prohledávání grafu, na které existuje mnoho
známých algoritmů. Pokud ale potřebujeme udržovat kromě dat o cestní síti data o
jízdních řádech, stává se situace mnohem složitější, protože zatímco po cestách
můžeme jít kdykoli, cestovat hromadnou dopravou můžeme pouze tehdy, když zrovna
jede nějaký spoj. Pro reprezentaci sítí hromadné dopravy se vyvinuly různé
způsoby, dále představíme nejobvyklejší z nich.

\section{Time-dependent modely}
Time-dependent modely \cite{time-dependent} se snaží odstranit problém s
velikostí grafu hromadné dopravy. Místo toho, abychom měli pro každý spoj
zvláštní hranu, sdružíme spoje do linek, kde všechny spoje jedné linky mají
stejnou posloupnost zastávek. Vrcholy tentokrát budou jen jeden pro každou
zastávku. Hrany mezi zastávkami budou jedna pro každou linku, která danou
dvojici zastávek spojuje. V takovémto grafu již nemůžeme vyhledávat pomocí
běžného průchodu grafu, potřebujeme mít upravenou funkci, která vyhledá v
jednotlivých časech odjezdu pro každou linku nejbližší od okamžiku příjezdu do
zastávky. Tento přístup nevytváří grafy s velkým počtem vrcholů a hran, navíc je
tato reprezentace snáze připojitelná do vyhledávacího grafu pro obyčejnou cestní
síť. U této varianty také existuje varianta, která má jeden staniční vrchol a
pro každou linku projíždějící danou stanicí linkový vrchol. Tyto vrcholy jsou
pak propojeny přestupovými hranami a umožňují realističtější modelování
rozsáhlejších stanic a přestupů v rámci nich. Ani tento model však nevyužívá
všech vlastností spojů MHD, jako je například to, že spoj má danou trasu a že
když na něj někde nastoupíme, tak snadno můžeme do fronty přidat všechny
průjezdní stanice.  

\section{Time expanded modely}
Time-expanded modely \cite{time-expanded} jsou konstruovány tak, aby ceny hran
byly konstantní a šlo na takovýto graf použít běžné vyhledávání v grafu. V
těchto modelech jsou jako vrcholy dvojice (zastávka, čas odjezdu) a (zastávka,
čas příjezdu) pro každý čas odjezdu a příjezdu z každé zastávky. Hrany pak
jsou jednak \uv{spojové} spojující vždy dvojici odjezd-příjezd mezi dvěma
zastávkami pomocí nějakého spoje, jednak \uv{čekací}, které spojují jednotlivé
časy v rámci jedné zastávky tak, jak jde čas. Spojení pak hledáme tak, že na
množině vrcholů patřících k výchozí zastávce najdeme vrchol s nejbližším vyšším
časem, než je náš odjezdový. Běžným průchodem do šířky podle času přes spojové a
čekací hrany pak najdeme cestu do cílové zastávky. Nevýhodou této reprezentace
je velikost grafu.

Tento základní model nerespektuje časy potřebné pro přestup, což může být
zvlášť problematické u rozsáhlých stanic či zastávek s mnoha zastávkovými
stojany. Tento problém se dá vyřešit rozdělením linie událostí u jedné zastávky
na více. Vrcholy patřící k jedné zastávce rozdělíme na zastávkové, příjezdové a
odjezdové. Odjezdové vrcholy odpovídají odjezdům spojů ze zastávky a příjezdové
vrcholy příjezdům do zastávky. Zastávkové vrcholy odpovídají každý jednomu
odjezdovému vrcholu. Zastávkové vrcholy jsou spojeny hranami do posloupnosti
stejně jako v původním grafu. Z příjezdového vrcholu vedou hrany do nejbližšího
zastávkového vrcholu, do kterého se stihne pěší přesun a do všech dřívějších
odjezdových vrcholů, do kterých se stihne pěší přesun. Ze zastávkového vrcholu
vede navíc hrana do odpovídajícího odjezdového vrcholu. 
\TODO obrázek
\section{Contraction hierarchy}
\section{RAPTOR}
RAPTOR (Round-Based Public Transport Routing) \citep*{RAPTOR} je oproti
time-dependent modelům založen na zcela odlišných myšlenkách a při svém běhu
nevyužívá Dijkstrův algoritmus. RAPTOR se snaží využít co nejvíce vlastností,
kterými se odlišuje síť veřejné dopravy od obyčejné cestní sítě. Také umožňuje
snadno optimalizovat na počet přestupů.

Algoritmus pracuje po kolech. Každé kolo zanmená nástup do dalšího dopravního
prostředku, celkově je tedy počet kol o 1 větší než maximální počet přestupů.
Algoritmus pracuje s linkami. Každá linka má několik spojů, což jsou konkrétní
vozidla, která všechna projíždí stejnou posloupnost zastávek. Každý spoj má
uloženy časy odjezdu z jednotlivých zastávek, předpokládáme, že se dva spoje
jedné linky na trase nepředjíždí. Pro každou zastávku si pro každé kolo
pamatujeme, zda a kdy je dosažitelná pomocí kterého kola. Nedosažitelnost
zastávky reprezentujeme pomocí nastavení času příjezdu v daném kole na $\infty$.

Na začátku jsou všechny zastávky ve všech kolech nedosažitelné. Nastavíme
výchozí zastávce čas dosažení v prvním kole na zadaný čas odjezdu a spustíme
algoritmus. Ten postupně prochzí linky po jejich zastávkách a pokud narazí na
dosažitelnou zastávku, tak najde nejbližší spoj linky, který z dané zastávky
odjíždí po čase dosažitelnosti a tímto spojem se \uv{vydá} a průběžně upravuje
časy dosažitelnosti na dalších zastávkách. Pokud po cestě nalezne další
dosažitelnou zastávku, jako spoj z této zastávky vybere ten z původního spoje a
spoje navazujícího na původní čas dosažitelnosti, který odjíždí dříve a takto
pokračuje až do konce linky. Po průchodu všech linek se všechny časy
dosažitelnosti zkopírují do dalšího kola a algoritmus se znovu spustí. Po
stanoveném počtu kol algoritmus skončí a u jednotlivých zastávek je pro každé
kolo (odpovídající počtu přestupů - 1) uloženo, zda je s daným počtem přestupů
dosažitelná a v jakém čase. K jednotlivým časům u zastávek je vhodné si uložit
ilinku, která způsobila úpravu na daný čas, abychom byli schopni zrekonstruovat
spojení využité k dosažení dané zastávky. 

Tento algoritus je snadno implementovatelný a při vhodně zvolených datových
strukturách velmi rychlý a vhodně využívající keš. 

\subsection{Uložení dat}
Pro rychlý výpočet a efektivní využití cache je potřeba mít vhodně uložená data.
Data stejného typu jsou vždy uložená v poli za sebou. Pokud různé objekty mají
každý mít seznam stejného typu, jsou všechna data od všech objektů držena v
jednom poli a každý objekt si drží počet svých prvků a odkaz na první z nich.
Tímto má každý objekt vyhrazen svůj úsek a může s ním efektivně pracovat. Tento
mechanismus nazveme \uv{polním mechanismem} a budeme na něj takto odkazovat ve
zbytku kapitoly.

Základem pro prohledávání je pole linek. Každá linka má odkaz na své zastávky a
na časy zastavení spojů v zastávkách. Obojí je implementováno polním mechanismem
a rozdělení na zastávky a spoje zajišťuje snadnou možnost hledání spojů v daný
čas. Časy zastavení spojů v zastávkách jsou uspořádány v poli za sebou podle
zastávek a pak podle času výjezdu spoje z výchozí zastávky. Protože
předpokládáme, že se spoje nepředjíždí a všechny spoje jedné linky mají stejný
počet zastávek, na předchozí spoj snadno přejdeme skokem v poli zastavení o
počet zastávek linky vzad, následující spoj najdeme obdobným skokem vpřed. Také
je možné pro konkrétní zastávku a konkrétní čas použít jednoduše binární
vyhledávání pro nalezení nejbližšího spoje odjíždějícího po konkrétním čase. 

Pro vyhledávání z konkrétní zastávky máme obdobně implementovány datové
struktury kolem zastávek. Zastávky jsou uloženy v poli za sebou, každá si drží
seznam linek, které jí projíždějí, a seznam pěších přestupů z dané zastávky. 
Obojí je reprezentováno polním mechanismem.   


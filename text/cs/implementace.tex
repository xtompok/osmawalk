\chapter{Implementace}
Pro implementaci programu převádějícího OSM data do formátu vyhledávacího grafu
jsme zvolili v první části Python, protože pro něj existuje široké množství
knihoven, které nám pomohly při řešení jednotlivých dílčích problémů. Při
vytváření spojek mezi cestami a jejich následné kontrole již ale nedostačoval,
proto tuto a další části jsme implementovali v jazyce C. Mezi těmito částmi
předáváme data pomocí Protocol Bufferu v souboru. Vyhledávání je také
implementováno v jazyce C kvůli rychlosti a paměťové nenáročnosti.

\section{Použité knihovny a pomocné programy}
Během implementace programu pro přípravu dat jsme se snažili použít co nejvíce
již existujících knihoven a programů pro jednotlivé řešené problémy. Všechny
tyto knihovny a programy jsou nutné pro spuštění a používání programu. 

\medskip
\noindent Používáme tyto pomocné programy:
\begin{itemize}
	\item Výřez s městem z dat pro republiku vyrábíme pomocí 
	{\tuc Osmconvert} (GNU AGPL)\footurl{http://wiki.openstreetmap.org/wiki/Osmconvert}.
	\item Pro práci s Protocol Buffery v Pythonu využíváme třídy generované
	kompilátorem {\tuc protoc} (BSD	New).\footurl{http://code.google.com/p/protobuf/}.
	\item Pro práci s Protocol Buffery v C využíváme funkce a struktury
	generované kompilátorem {\tuc protobuf-c} 
	(BSD 2-Clause)\footurl{https://github.com/protobuf-c/protobuf-c}.
\end{itemize}

\noindent V programech napsaných v Pythonu využíváme následující knihovny:
\begin{itemize}
	\item Na parsování konfiguračních souborů používáme 
	{\tuc PyYAML} (MIT)\footurl{http://pyyaml.org/wiki/PyYAML}.
	\item Na parsování OSM XML používáme {\tuc imposm.parser} 
	(Apache)\footurl{http://imposm.org/docs/imposm.parser/latest/}.
	\item Souřadnice konvertujeme pomocí {\tuc pyproj}
	(MIT)\footurl{http://code.google.com/p/pyproj/}.
	\item Pro hledání komponent grafu využíváme {\tuc networkx} 
	(BSD)\footurl{http://networkx.github.io/}.
\end{itemize}

\noindent V programech napsaných v C využíváme následující knihovny:
\begin{itemize}
	\item Datové struktury, dynamická pole a další potřebné funkce zajišťuje
	{\tuc LibUCW} (GNU LGPL)\footurl{http://www.ucw.cz/libucw/}.
	\item Výpočty se zeměpisnými souřadnicemi provádí {\tuc PROJ.4}
	(MIT)\footurl{http://trac.osgeo.org/proj/}.
\end{itemize}

Program osmconvert je již zahrnut ve zdrojovém kódu, ostatní knihovny je potřeba
zajistit v systému.

\section{Datové struktury}
V průběhu celé přípravy vyhledávacích dat často využíváme několik struktur,
které nyní popíšeme. Datové struktury využívané jen v konkrétních případech
popíšeme u těchto případů.

Při přípravě dat používáme několik {\tuc hešovacích tabulek}. Často potřebujeme
získat uzel respektive cestu s konkrétním identifikátorem, pro tento účel nám
slouží tabulky \verb|nodesIdx| respektive \verb|waysIdx|. V Pythonu jsou
reprezentovány typem slovník, v C využíváme součást knihovny libUCW
\verb|hashtable|. V obou případech je klíčem OSM identifikátor objektu a
hodnotou index do pole uzlů resp. cest, kde je daný objekt uložen.

U každé cesty je v datech uložen seznam uzlů, přes které prochází. Je ale vhodné
mít i pro každý vrchol uložen seznam cest, které jím prochází. Pro tento účel
máme seznam \verb|nodeWays|. Je to seznam seznamů, kdy pod indexem $i$ je seznam
všech identifikátorů cest, které prochází vrcholem na indexu $i$. V Pythonu jde
o seznam seznamů, v C je to rostoucí pole rostoucích polí z libUCW.

Během zpracování hledáme uzly blízké daným uzlů. Abychom pro každé takové
hledání nemuseli procházet všechny uzly, vytvoříme si na začátku {\tuc mřížku}.
Tato mřížka dělí plochu mapy na čtverce $20 \times 20$\,m a v každém čtverci si
uložíme seznam identifikátorů vrcholů, které v něm leží. Poté nám při hledání
sousedů bodu stačí zjistit, do kterého čtverce patří a následně prohledat jen
několik okolních čtverců.

V Pythonu se jedná o třídu \verb|Raster|, která při vytvoření vyrobí mřížku z
mapy. Mřížka je uložena v atributu \verb|raster|, třída má metodu
\verb|getBox(lon,lat)|, která pro bod s  délku \verb|lon| a šířku \verb|lat|
vrátí tuple se souřadnicemi buňky, ve které se bod nachází. Mřížka \verb|raster|
je seznam seznamů seznamů.

V C je mřížka reprezentována strukturou \verb|raster_t|. Samotná mřížka je prvek
\verb|raster| této struktury. V souboru \verb|raster.h| jsou definovány funkce
pro práci s mřížkou. Funkce \verb|makeRaster(map_t map)| vyrobí z mapy mřížku a
vrátí ji. Funkce \verb|getRasterBox(raster_t raster, int64_t lon, int64_t lat)|
dostane jako paramter mřížku, délku a šířku bodu a vrátí pole se dvěma prvky --
souřadnicemi buňky, kde se bod nachází. Mřížka \verb|raster| je reprezentována
rostoucím polem rostoucích polí rostoucích polí z knihovny libUCW.

\medskip


\section{Stažení dat OSM}
Abychom mohli připravovat data pro vyhledávání, musíme nejprve získat data OSM
pro dané město. O tuto činnost se stará skript \verb|prepare.sh|, který stáhne
data pro celou Českou republiku a pomocí osmconvert z ní vyřízne obdélník s
městem. Ten uloží jako \verb|praha.osm|\footnote{Program byl připravován pro
vyhledávání tras po Praze, proto soubory obvykle obsahují název praha.} k
dalšímu zpracování.

\section{Klasifikace dat}
Nejdříve potřebujeme data OSM převést do formátu pro přípravu dat (premap). K
tomuto účelu slouží program \verb|parse.py|, který si načte konfigurační soubory
a podle nich rozdělí jednotlivé uzly a cesty do kategorií. Současně také převede
souřadnice do formátu UTM. Následně smaže všechny uzly, které neleží na žádné
cestě a uloží data do formátu premap.

Konfigurační soubory jsou soubory ve formátu YAML. Používají se následující
konfigurační soubory:
\begin{itemize}
	\item \verb|types.yaml| pro rozdělení cest a multipolygonů do
kategorií 
	\item \verb|area.yaml| pro určení, zda je daný objekt plochou
	\item \verb|tunnel.yaml| pro určení, zda je daný objekt tunelem,
	průchodem či jinou podobnou stavbou
	\item \verb|bridge.yaml| pro určení, zda je daný objekt mostem nebo na
	něm leží
\end{itemize}

Konfigurační soubory mají následující formát:
\begin{verbatim}
barrier: 
    barrier : "*"
    waterway:
        - river
        - canal
water:
    waterway:
        - riverbank
        - stream
\end{verbatim}
Konfigurační soubor se skládá z několika mapování, u každého klíč určuje, jaká
kategorie resp. hodnota se přiřadí, hodnotou mapování první úrovně jsou mapování
druhé úrovně, které určují, za jakých podmínek se hodnota přiřadí. Přiřazuje se
vždy, když je splněna alespoň jedna podmínka. 

V mapování druhé úrovně je klíčem vždy klíč vlastnosti objektu OSM. Hodnota může
být dvou druhů. Buď je to \verb|"*"|, pak stačí, že se shoduje klíč vlastnosti
OSM a na hodnoty se nehledí, nebo je hodnota mapování seznam hodnot objektu OSM.
Pokud má objekt OSM pro daný klíč jednu z těchto hodnot, je  podmínka splněna. 

V příkladu rozdělujeme do kategorií \verb|barrier| a \verb|water|. Pokud má
objekt OSM nějaký atribut s klíčem \verb|barrier|, je tomuto objektu přiřazena
kategorie \verb|barrier| nezávisle na hodnotě tohoto klíče. Obdobně je jako
\verb|barrier| označen objekt OSM, který má atribut s klíčem \verb|waterway| a
hodnotou \verb|river|. Pokud má ale objekt atribut s klíčem \verb|waterway| a
hodnotou \verb|stream|, je klasifikován jako \verb|water|.

Při procházení uzlů převádíme souřadnice do formátu UTM\cite{utmnorma}. Tento
formát používá místo stupňů metry, tudíž se v něm lépe počítají vzdálenosti. To
se nám hodí nejen při přípravě dat, ale i při samotném hledání, protože při
testování se souřadnicemi ve formátu WGS-84 se více času trávilo výpočtem
vzdáleností než zbytkem algoritmu. V našem případě ještě {\tuc vynásobíme souřadnice
UTM desíti}, čímž bude jednotkou 10\,cm což nám jako přesnost stačí a můžeme
všechny výpočty provádět v celých číslech.

Následně vytvoříme hešovací tabulku nodeWays a jejím průchodem zjistíme, které
uzly neleží na žádných cestách a tyto uzly smažeme. Nakonec převedeme data do
formátu premap a uložíme jako soubor \verb|praha-pre.pbf| do složky \verb|data|.

\section{Převod multipolygonů na cesty}
S multipolygony se v původní formě pracuje obtížně, protože se jejich obvod
skládá z neseřazených cest. Pro naše účely se hodí vytvořit cesty reprezentující
obvod multipolygonu. Těchto cest může být více, protože multipolygon se může
skládat z více komponent. 

Pro každý multipolygon si vytvoříme seznam všech vnějších cest. Pak vytvoříme
seznam sousedů \verb|neighs|, který pro každý uzel na některé z vnějších cest
obsahuje jeho sousedy na těchto cestách. Ve správném případě by takto měl každý
uzel mít dva sousedy. Pokud tomu tak není, skončíme s chybou. Poté vybereme
jeden uzel na obvodu a postupujeme po jeho sousedech, dokud se do něj opět
nevrátíme. Použité cesty smažeme ze seznamu všech cest a opakujeme, dokud nějaké
cesty zbývají. Pokud se vrátíme na vytvářenou cestu mimo první vrchol, skončíme
s chybou.

\section{Spojení budov}
Při spojování bloků budov do jejich obrysu si nejprve vytvoříme graf sousednosti
budov. Pro jeho reprezentaci použijeme knihovnu \verb|networkx|. Jednotlivé
budovy budou vrcholy v grafu, pokud budovy sousední, bude mezi jejich vrcholy
hrana. Graf sousednosti vytváříme funkcí \verb|makeNeighGraph|.

Do grafu nejprve přidáme všechny budovy jako vrcholy. Následně procházíme
všechny uzly a u každého zkoumáme cesty, které jím prochází. Pokud jde jen o
budovy, pak mezi první budovou a všemi ostatními vytvoříme v grafu hrany. Pokud
mezi cestami je i nějaká, která není budovou, pak jsou všechny sousední budovy
označeny za vadné a hrany nepřidáváme.

Když máme graf vytvořen, procházíme ve funkci \verb|mergeComponents| jednotlivé
jeho komponenty a ze všech cest v komponentě, které nejsou vadné, se pokoušíme
vytvořit cestu. Pokud se to povede, přidáme ji mezi cesty a původní cesty
jednotlivých budov vložíme do seznamu ke smazání. Nakonec funkcí
\verb|removeMerged| smažeme všechny budovy, které jsme nahradili jejich obvodem.

Když vytváříme cestu z obvodu bloku budov pomocí funkce \verb|mergeWays|,
postupujeme obdobně jako při převodu multipolygonů na cesty. Vytvoříme si seznam
\verb|neighs|, který obsahuje pro každý bod na některé ze spojovaných cest
všechny jeho sousedy. Tentokrát ale může být sousedů více a je potřeba vybrat
toho správného. Setřídíme si tedy uzly podle souřadnic a ten nejvíce na
jihozápadě vezmeme jako první uzel obvodu.  Protože žádný západnější ani
jižnější bod neexistuje, bude tento uzel zcela jistě na obvodu. Nyní najdeme
druhý uzel na obvodu. Vybereme mezi sousedy prvního uzlu ten, který svírá s
úsečkou vedoucí z prvního uzlu na jih nejmenší úhel. Žádný uzel přímo na jih od
prvního není, proto všechny úhly budou nenulové. Uzel pod nejmenším úhlem bude
druhým na obvodu.

Pokud máme první dva body na obvodu, stačí nám již jen ze sousedů aktuálně
zpracovávaného uzlu vybrat ten uzel, který svírá s předchozím a aktuálním uzlem
nejmenší vnější úhel a takto pokračovat, dokud se nevrátíme do prvního uzlu.

Jestliže počet uzlů je méně než tři, nejde o korektní plochu a je vrácena chyba.
Rovněž pokud během průchodu po obvodu dojdeme do jiného než prvního bodu na
obvodu, například pokud se dvě cesty dotýkají rohem, vrátíme chybu.
% TODO: Obrázky

\section{Rozdělení dlouhých úseků}
Dlouhé přímé cesty mívají i úseky mezi uzly dlouhé. V případě, že například v
polovině tohoto úseku silnice končí souběžný chodník, chceme navázat cestu z
chodníku na silnici spojkou. Protože spojky chceme mít krátké, hodí se nám mít i
krátké úseky mezi uzly a tím mít možnost kdekoli podél cesty na ni udělat
spojku. Projdeme tedy všechny cesty a na každé kontrolujeme délky úseků. Pokud
najdeme úsek delší než 30 metrů, rozdělíme ho po 20 metrech vytvořením nových
uzlů vložených mezi stávající.

\section{Smíšená čísla}
Při hledání spojek mezi cestami a zkratek přes průchozí prostranství využíváme
pro některé výpočty smíšených čísel. Důvodem pro jejich využití je nedostatečná
přesnost 64bitových celých čísel. Předpokládejme, že máme město velikosti
Prahy, což je přibližně $20 \times 30$\,km. Používáme přesnost 10\,cm, tudíž
potřebujeme rozlišení $\log_2{\frac{30 000}{0.1}}\doteq18.2$ bitů. 

Při počítání průsečíků úseček využíváme na neceločíselné výsledky zlomky,
abychom neztratili přesnost. Ve zlomcích se může vyskytnout součin dvou
souřadnic, který může být až 38 bitů velký. Pokud takovéto zlomky potřebujeme
porovnávat, potřebujeme čitatele prvního zlomku vynásobit se jmenovatelem
druhého zlomku, na což bychom mohli potřebovat až 76 bitů, tudíž by nám
nestačilo 64bitové celé číslo. 

Pokud porovnáváme dvě smíšená čísla, tak buď budou od sebe vzdálená, tudíž se
budou lišit v celé části a násobení provádět nemusíme. Jestliže se čísla v celé
části shodují, pak je potřeba násobit čitatele a jmenovatele. TODO: Rozumný
popis.


\section{Spojky mezi cestami}
\section{Zkratky přes průchozí prostranství}
\section{Vytvoření vyhledávacího grafu}

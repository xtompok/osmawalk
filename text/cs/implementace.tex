\chapter{Implementace}
Pro implementaci programu převádějícího OSM data do formátu vyhledávacího grafu
jsme zvolili v první části Python, protože pro něj existuje široké množství
knihoven, které nám pomohly při řešení jednotlivých dílčích problémů. Při
vytváření spojek mezi cestami a jejich následné kontrole již ale nedostačoval,
proto tuto a další části jsme implementovali v jazyce C. Mezi těmito částmi
předáváme data pomocí Protocol Bufferu v souboru. Vyhledávání je také
implementováno v jazyce C kvůli rychlosti a paměťové nenáročnosti.

\section{Použité knihovny a pomocné programy}
Během implementace programu pro přípravu dat jsme se snažili použít co nejvíce
již existujících knihoven a programů pro jednotlivé řešené problémy. Všechny
tyto knihovny a programy jsou nutné pro spuštění a používání programu. 

\medskip
\noindent Používáme tyto pomocné programy:
\begin{itemize}
	\item Výřez s městem z dat pro republiku vyrábíme pomocí 
	{\tuc Osmconvert} (GNU AGPL)\footurl{http://wiki.openstreetmap.org/wiki/Osmconvert}.
	\item Pro práci s Protocol Buffery v Pythonu využíváme třídy generované
	kompilátorem {\tuc protoc} (BSD	New).\footurl{http://code.google.com/p/protobuf/}.
	\item Pro práci s Protocol Buffery v C využíváme funkce a struktury
	generované kompilátorem {\tuc protobuf-c} 
	(BSD 2-Clause)\footurl{https://github.com/protobuf-c/protobuf-c}.
\end{itemize}

\noindent V programech napsaných v Pythonu využíváme následující knihovny:
\begin{itemize}
	\item Na parsování konfiguračních souborů používáme 
	{\tuc PyYAML} (MIT)\footurl{http://pyyaml.org/wiki/PyYAML}.
	\item Na parsování OSM XML používáme {\tuc imposm.parser} 
	(Apache)\footurl{http://imposm.org/docs/imposm.parser/latest/}.
	\item Souřadnice konvertujeme pomocí {\tuc pyproj}
	(MIT)\footurl{http://code.google.com/p/pyproj/}.
	\item Pro hledání komponent grafu využíváme {\tuc networkx} 
	(BSD)\footurl{http://networkx.github.io/}.
\end{itemize}

\noindent V programech napsaných v C využíváme následující knihovny:
\begin{itemize}
	\item Datové struktury, dynamická pole a další potřebné funkce zajišťuje
	{\tuc LibUCW} (GNU LGPL)\footurl{http://www.ucw.cz/libucw/}.
	\item Výpočty se zeměpisnými souřadnicemi provádí {\tuc PROJ.4}
	(MIT)\footurl{http://trac.osgeo.org/proj/}.
\end{itemize}

Program osmconvert je již zahrnut ve zdrojovém kódu, ostatní knihovny je potřeba
zajistit v systému.

\section{Datové struktury}
V průběhu celé přípravy vyhledávacích dat často využíváme několik struktur,
které nyní popíšeme. Datové struktury využívané jen v konkrétních případech
popíšeme u těchto případů.

Při přípravě dat používáme několik {\tuc hešovacích tabulek}. Často potřebujeme
získat uzel respektive cestu s konkrétním identifikátorem, pro tento účel nám
slouží tabulky \verb|nodesIdx| respektive \verb|waysIdx|. V Pythonu jsou
reprezentovány typem slovník, v C využíváme součást knihovny libUCW
\verb|hashtable|. V obou případech je klíčem OSM identifikátor objektu a
hodnotou index do pole uzlů resp. cest, kde je daný objekt uložen.

U každé cesty je v datech uložen seznam uzlů, přes které prochází. Je ale vhodné
mít i pro každý vrchol uložen seznam cest, které jím prochází. Pro tento účel
máme seznam \verb|nodeWays|. Je to seznam seznamů, kdy pod indexem $i$ je seznam
všech identifikátorů cest, které prochází vrcholem na indexu $i$. V Pythonu jde
o seznam seznamů, v C je to rostoucí pole rostoucích polí z libUCW.

Během zpracování hledáme uzly blízké daným uzlů. Abychom pro každé takové
hledání nemuseli procházet všechny uzly, vytvoříme si na začátku {\tuc mřížku}.
Tato mřížka dělí plochu mapy na čtverce $20 \times 20$\,m a v každém čtverci si
uložíme seznam identifikátorů vrcholů, které v něm leží. Poté nám při hledání
sousedů bodu stačí zjistit, do kterého čtverce patří a následně prohledat jen
několik okolních čtverců.

V Pythonu se jedná o třídu \verb|Raster|, která při vytvoření vyrobí mřížku z
mapy. Mřížka je uložena v atributu \verb|raster|, třída má metodu
\verb|getBox(lon,lat)|, která pro bod s  délku \verb|lon| a šířku \verb|lat|
vrátí tuple se souřadnicemi buňky, ve které se bod nachází. Mřížka \verb|raster|
je seznam seznamů seznamů.

V C je mřížka reprezentována strukturou \verb|raster_t|. Samotná mřížka je prvek
\verb|raster| této struktury. V souboru \verb|raster.h| jsou definovány funkce
pro práci s mřížkou. Funkce \verb|makeRaster(map_t map)| vyrobí z mapy mřížku a
vrátí ji. Funkce \verb|getRasterBox(raster_t raster, int64_t lon, int64_t lat)|
dostane jako paramter mřížku, délku a šířku bodu a vrátí pole se dvěma prvky --
souřadnicemi buňky, kde se bod nachází. Mřížka \verb|raster| je reprezentována
rostoucím polem rostoucích polí rostoucích polí z knihovny libUCW.

\medskip


\section{Stažení dat OSM}
Abychom mohli připravovat data pro vyhledávání, musíme nejprve získat data OSM
pro dané město. O tuto činnost se stará skript \verb|prepare.sh|, který stáhne
data pro celou Českou republiku a pomocí osmconvert z ní vyřízne obdélník s
městem. Ten uloží jako \verb|praha.osm|\footnote{Program byl připravován pro
vyhledávání tras po Praze, proto soubory obvykle obsahují název praha.} k
dalšímu zpracování.

\section{Klasifikace dat}
Nejdříve potřebujeme data OSM převést do formátu pro přípravu dat (premap). K
tomuto účelu slouží program \verb|parse.py|, který si načte konfigurační soubory
a podle nich rozdělí jednotlivé uzly a cesty do kategorií. Současně také převede
souřadnice do formátu UTM. Následně smaže všechny uzly, které neleží na žádné
cestě a uloží data do formátu premap.

Konfigurační soubory jsou soubory ve formátu YAML. Používají se následující
konfigurační soubory:
\begin{itemize}
	\item \verb|types.yaml| pro rozdělení cest a multipolygonů do
kategorií 
	\item \verb|area.yaml| pro určení, zda je daný objekt plochou
	\item \verb|tunnel.yaml| pro určení, zda je daný objekt tunelem,
	průchodem či jinou podobnou stavbou
	\item \verb|bridge.yaml| pro určení, zda je daný objekt mostem nebo na
	něm leží
\end{itemize}

Konfigurační soubory mají následující formát:
\begin{verbatim}
barrier: 
    barrier : "*"
    waterway:
        - river
        - canal
water:
    waterway:
        - riverbank
        - stream
\end{verbatim}
Konfigurační soubor se skládá z několika mapování, u každého klíč určuje, jaká
kategorie resp. hodnota se přiřadí, hodnotou mapování první úrovně jsou mapování
druhé úrovně, které určují, za jakých podmínek se hodnota přiřadí. Přiřazuje se
vždy, když je splněna alespoň jedna podmínka. 

V mapování druhé úrovně je klíčem vždy klíč vlastnosti objektu OSM. Hodnota může
být dvou druhů. Buď je to \verb|"*"|, pak stačí, že se shoduje klíč vlastnosti
OSM a na hodnoty se nehledí, nebo je hodnota mapování seznam hodnot objektu OSM.
Pokud má objekt OSM pro daný klíč jednu z těchto hodnot, je  podmínka splněna. 

V příkladu rozdělujeme do kategorií \verb|barrier| a \verb|water|. Pokud má
objekt OSM nějaký atribut s klíčem \verb|barrier|, je tomuto objektu přiřazena
kategorie \verb|barrier| nezávisle na hodnotě tohoto klíče. Obdobně je jako
\verb|barrier| označen objekt OSM, který má atribut s klíčem \verb|waterway| a
hodnotou \verb|river|. Pokud má ale objekt atribut s klíčem \verb|waterway| a
hodnotou \verb|stream|, je klasifikován jako \verb|water|.

Při procházení uzlů převádíme souřadnice do formátu UTM\cite{utmnorma}. Tento
formát používá místo stupňů metry, tudíž se v něm lépe počítají vzdálenosti. To
se nám hodí nejen při přípravě dat, ale i při samotném hledání, protože při
testování se souřadnicemi ve formátu WGS-84 se více času trávilo výpočtem
vzdáleností než zbytkem algoritmu. V našem případě ještě {\tuc vynásobíme souřadnice
UTM desíti}, čímž bude jednotkou 10\,cm což nám jako přesnost stačí a můžeme
všechny výpočty provádět v celých číslech.

Následně vytvoříme hešovací tabulku nodeWays a jejím průchodem zjistíme, které
uzly neleží na žádných cestách a tyto uzly smažeme. Nakonec převedeme data do
formátu premap a uložíme jako soubor \verb|praha-pre.pbf| do složky \verb|data|.

\section{Převod multipolygonů na cesty}
S multipolygony se v původní formě pracuje obtížně, protože se jejich obvod
skládá z neseřazených cest. Pro naše účely se hodí vytvořit cesty reprezentující
obvod multipolygonu. Těchto cest může být více, protože multipolygon se může
skládat z více komponent. 

Pro každý multipolygon si vytvoříme seznam všech vnějších cest. Pak vytvoříme
seznam sousedů \verb|neighs|, který pro každý uzel na některé z vnějších cest
obsahuje jeho sousedy na těchto cestách. Ve správném případě by takto měl každý
uzel mít dva sousedy. Pokud tomu tak není, skončíme s chybou. Poté vybereme
jeden uzel na obvodu a postupujeme po jeho sousedech, dokud se do něj opět
nevrátíme. Použité cesty smažeme ze seznamu všech cest a opakujeme, dokud nějaké
cesty zbývají. Pokud se vrátíme na vytvářenou cestu mimo první vrchol, skončíme
s chybou.

\section{Spojení budov}
Při spojování bloků budov do jejich obrysu si nejprve vytvoříme graf sousednosti
budov. Pro jeho reprezentaci použijeme knihovnu \verb|networkx|. Jednotlivé
budovy budou vrcholy v grafu, pokud budovy sousední, bude mezi jejich vrcholy
hrana. Graf sousednosti vytváříme funkcí \verb|makeNeighGraph|.

Do grafu nejprve přidáme všechny budovy jako vrcholy. Následně procházíme
všechny uzly a u každého zkoumáme cesty, které jím prochází. Pokud jde jen o
budovy, pak mezi první budovou a všemi ostatními vytvoříme v grafu hrany. Pokud
mezi cestami je i nějaká, která není budovou, pak jsou všechny sousední budovy
označeny za vadné a hrany nepřidáváme.

Když máme graf vytvořen, procházíme ve funkci \verb|mergeComponents| jednotlivé
jeho komponenty a ze všech cest v komponentě, které nejsou vadné, se pokoušíme
vytvořit cestu. Pokud se to povede, přidáme ji mezi cesty a původní cesty
jednotlivých budov vložíme do seznamu ke smazání. Nakonec funkcí
\verb|removeMerged| smažeme všechny budovy, které jsme nahradili jejich obvodem.

Když vytváříme cestu z obvodu bloku budov pomocí funkce \verb|mergeWays|,
postupujeme obdobně jako při převodu multipolygonů na cesty. Vytvoříme si seznam
\verb|neighs|, který obsahuje pro každý bod na některé ze spojovaných cest
všechny jeho sousedy. Tentokrát ale může být sousedů více a je potřeba vybrat
toho správného. Setřídíme si tedy uzly podle souřadnic a ten nejvíce na
jihozápadě vezmeme jako první uzel obvodu.  Protože žádný západnější ani
jižnější bod neexistuje, bude tento uzel zcela jistě na obvodu. Nyní najdeme
druhý uzel na obvodu. Vybereme mezi sousedy prvního uzlu ten, který svírá s
úsečkou vedoucí z prvního uzlu na jih nejmenší úhel. Žádný uzel přímo na jih od
prvního není, proto všechny úhly budou nenulové. Uzel pod nejmenším úhlem bude
druhým na obvodu.

Pokud máme první dva body na obvodu, stačí nám již jen ze sousedů aktuálně
zpracovávaného uzlu vybrat ten uzel, který svírá s předchozím a aktuálním uzlem
nejmenší vnější úhel a takto pokračovat, dokud se nevrátíme do prvního uzlu.

Jestliže počet uzlů je méně než tři, nejde o korektní plochu a je vrácena chyba.
Rovněž pokud během průchodu po obvodu dojdeme do jiného než prvního bodu na
obvodu, například pokud se dvě cesty dotýkají rohem, vrátíme chybu.
% TODO: Obrázky

\section{Rozdělení dlouhých úseků}
Dlouhé přímé cesty mívají i úseky mezi uzly dlouhé. V případě, že například v
polovině tohoto úseku silnice končí souběžný chodník, chceme navázat cestu z
chodníku na silnici spojkou. Protože spojky chceme mít krátké, hodí se nám mít i
krátké úseky mezi uzly a tím mít možnost kdekoli podél cesty na ni udělat
spojku. Projdeme tedy všechny cesty a na každé kontrolujeme délky úseků. Pokud
najdeme úsek delší než 30 metrů, rozdělíme ho po 20 metrech vytvořením nových
uzlů vložených mezi stávající.

\section{Reprezentace čísel}
V průběhu dalšího zpracování budeme potřebovat počítat průsečíky úseček daných
uzly. Protože průsečíky úseček nebudou mít celočíselné souřadnice, je potřeba
rozmyslet, jakým způsobem je reprezentovat.

{\tuc Čísla s plovoucí desetinnou čárkou} se pro tyto účely nehodí, protože
nejsou přesné. Při výpočtech s nimi vznikají zaokrouhlovací chyby, které mohou
zapříčinit špatné pořadí blízkých průsečíků v uspořádání. Potřebujeme proto
přesnou reprezentaci.

{\tuc Zlomky} jsou pro reprezentaci desetinných čísel vhodnější. Dokážeme pomocí
nich přesně reprezentovat desetinná čísla.  porovnávání. Zlomky můžeme vždy
upravit tak, aby jejich jmenovatel byl kladný.  Takové zlomky můžeme porovnávat
podle pravidla $\frac{a}{b} < \frac{c}{d} \Leftrightarrow a\cdot d < c\cdot b $. 
Pokud se nám ale stane, že porovnáváme dva zlomky, které mají vysoký čitatel i
jmenovatel, nemusí nám 64 bitů přesnosti stačit.

%TODO: Výpočet průsečíku

%TODO: přepsat
Předpokládejme, že máme město velikosti Prahy, což je přibližně $20 \times
30$\,km. Používáme přesnost 10\,cm, tudíž potřebujeme rozlišení $\log_2{\frac{30
000}{0.1}}\doteq18.2$ bitů. 

O úsečkách víme, že žádná nebude delší než 300 metrů. Potom nám z výše uvedeného
výpočtu vychází, že jmenovatel bude nejvýše 9 milionů, na jehož reprezentaci nám
stačí 24 bitů. Maximální čitatel TODO

{\tuc Smíšená čísla} nemají ani jednu z předchozích nevýhod. Jsou to čísla,
která mají tvar $a+\frac{b}{c}$, kde $\frac{b}{c}<1$. $a$ nazvěme základem, $b$
čitatelem a $c$ jmenovatelem. U těchto čísel je stejně jako u zlomků zachována
přesnost, ale nemají problém s porovnáním. Pokud se čísla liší v základu, pak
nemáme problém s přesností, protože základy se porovnávají přímo. Pokud mají dvě
smíšená čísla stejné základy, pak porovnáme jejich zlomky. To ale narozdíl od
přímého porovnávání zlomků není problém, protože jmenovatel je opět nejvýše
24bitový a protože čitatel je nejvýše tak velký jako jmenovatel, jejich
vynásobením vznikne nejvýše 48bitové číslo. Protože proměnné máme 64bitové,
nikde k přetečení nedojde.

Smíšená čísla jsou implementována jako struktury se členy \verb|base| pro
základ, \verb|numer| pro čitatele a \verb|denom| pro jmenovatele. Všechny
položky jsou 64bitová celá čísla a jmenovatel nesmí být záporný. Pro práci se
smíšenými čísly jsou definovány pomocné funkce v souboru \verb|mixnum.h|.

\section{Spojky mezi cestami}
Spojky budeme vytvářet mezi cestami, po kterých budeme posléze vyhledávat.
Nejprve si proto všechny cesty ve funkci \verb|makeGraph| projdeme a roztřídíme
do dvou polí. 

Pole \verb|wayGraph| obsahuje pro každý uzel pole všech jeho sousedů po cestách,
po kterých se bude vyhledávat. Pole \verb|barGraph| obshauje ty dvojice indexů
uzlů, které spolu sousedí na některé cestě označené jako překážka. Obě pole
reprezentují graf, první pomocí seznamu sousedů, druhý pomocí seznamu hran.
Každé pole budeme využívat jiným způsobem a proto se nám hodí různá
reprezentace.

Jako druhý krok nalezneme všechny kandidáty na spojky. Zde využijeme mřížky.
Protože spojky chceme dlouhé nejvíce 20 metrů a mřížka má čtverce o hraně také
20 metrů, stačí nám při hledání možných spojek pro daný bod se podívat pouze na
body ve čtverci, kde sám leží, v sousedních čtvercích napravo od něj a ve
čtverci pod ním. Protože jsou spojky kratší než 20\,m, nemohou dále než do sousedního
čtverce dosáhnout a protože procházíme postupně všechny čtverce, možné spojky
doleva a nahoru již známe ze zpracování předchozích čtverců. 

Jednotlivé počáteční a koncové body spojek získáme ze všech bodů v daném čtverci
vytříděním těch, které mají nějaké sousedy v poli \verb|wayGraph|. Rovněž
nepřidáváme každou spojku, ale náhodně jen některé z nich, čímž si příliš
nezhoršíme nejkratší trasu a ušetříme místo a čas při hledání.

Když máme připravené kandidáty na spojky a seznam všech překážek, můžeme
přistoupit k zametání roviny. Zametání roviny probíhá ve funkci
\verb|findDirectWays| a využívá následující datové typy a proměnné:
\begin{itemize}
	\item 
\end{itemize}

\section{Zkratky přes průchozí prostranství}
\section{Vytvoření vyhledávacího grafu}
Když již máme všechna data připravená, vytvoříme vyhledávací graf. Nejprve do
něj přidáme všechny vrcholy a hrany, tím ale nemáme zajištěno, že nebude mít
více komponent. Proto následně graf projdeme do hloubky a vybereme tu
komponentu, která bude mít více než polovinu vrcholů. Poté v grafu necháme jen
vrcholy a hrany co do této komponenty patří a graf uložíme. 
